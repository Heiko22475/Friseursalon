Kontext:
Ich baue ein CMS mit React + Tailwind. Persistenz über Supabase (Postgres). 
Bitte implementiere ein Farbsystem (Design Tokens), davon zunächst den UI-Editor, 
der mit Features wie Farbpallete bearbeiten aber auch eine datenbank-Gespeicherter
Liste hat, mit der man die aktuelle Einstellung überschreiben kann (Warnung!). 
Der FarbEditor soll auf der Hauptseite aufrufbar sein. 


Ziel-Funktionalität:
1) Palette (Systemfarben):
   - Genau 5 Hauptfarben: primary1..primary5
   - Jede Hauptfarbe hat:
     - base (pflicht)
     - accents (optional, z.B. accent1..accent3 ODER light/dark/muted). vom Programm her berechnet, nicht in der DB gespeichert
   - Farben werden als HEX gespeichert (normalisiert #RRGGBB)
   - In der Datenbank-Tabelle für die Palette soll es für die 5 Hauptfarben jeweils ein Tabellenfeld geben
2) Text-Mapping:
   - Für jedes Paletten-Token (z.B. palette.primary1.base, palette.primary1.accents.accent1) muss eine zugeordnete Textfarbe existieren:
     - Modus "auto" (berechne beste Textfarbe für Kontrast)
     - Modus "custom" (User wählt Hex)
3) Semantik-/Standardfarben:
   - Standardfarben sind Tokens wie:
     link, linkHover, pageBg, contentBg, cardBg, border, headingText, bodyText, mutedText,
     buttonPrimaryBg, buttonPrimaryText, buttonSecondaryBg, buttonSecondaryText, focusRing
   - Jede Standardfarbe ist ein ColorValue:
     - { kind: "tokenRef", ref: "palette.primary1.base" | "semantic.link" ... }
     - { kind: "custom", hex: "#..." }
   - In der UI muss ein UnifiedColorPicker existieren mit 3 Quellen:
     (A) Semantik (Standardfarben)
     (B) Palette (Hauptfarben + Akzente)
     (C) Custom (frei wählbar; optional begrenzen/Warning)
4) Token-Auflösung:
   - Implementiere resolveColor(ColorValue, tokenStore) -> HEX
   - Erkenne und verhindere Zyklen (cycle detection) bei tokenRef.
   - Implementiere resolveSemanticToken(name) -> ColorValue -> HEX
5) Tailwind Integration:
   - Exportiere CSS-Variablen (z.B. :root { --c-link: #...; --c-primary-1: #... })
   - Nutze Tailwind so, dass Komponenten Farben via CSS vars nutzen können:
     z.B. className="bg-[var(--c-card-bg)] text-[var(--c-body-text)]"
   - Baue eine Preview-Area (Cards, Buttons, Links, Section backgrounds), die live aus Tokens gerendert wird.
7) UX/Editor-Seite:
   Die Seite sollte eine Tabelle zeigen: 1. Zeile: die 5 Hauptfarben (base), 2.Zeile Akzentfarbe hell (geignet beispielsweise für Hintergründe), 3. Zeile Akzentfarbe dunkel (z.B. für Hintergründe)
   - Ich möchte vordefinierte Paletten anbieten können, die in der Datenbank gespeichert sind und aufgelistet werden. 
   - die 5 Primärfarben sollten mit einem Colorpicker ausgewählt werden können. 
   - In den Palettenfeldern sollten zu jeder Primär / Hell / Dunkelfarbe ebenfalls 
   eine Beispielschrift stehen, die man auch ändern kann. 
   
Technische Vorgaben

- Keine Hardcoded-Farben in UI-Komponenten: immer via resolveColor + CSS vars.
- Token-Refs als stabile Strings, z.B. "palette.primary1.base", "palette.primary1.accents.accent1", "semantic.link".
- Bitte erzeuge:
  1) Types: ThemeTokens, Palette, SemanticTokens, ColorValue, TextMapping
  2) Utilities: color parsing/normalize, luminance/contrast, autoTextColor, resolveColor, cycle detection
  4) UI components: UnifiedColorPicker, PaletteEditor, TextMappingEditor, SemanticColorsEditor, ThemePreview

Output von dir:
- Zuerst Architekturüberblick

Wichtige Semantik-Defaults:
- Lege sinnvolle Default-Werte an, die ohne Custom gut aussehen (z.B. pageBg hell, contentBg neutral, link = primary1.base, cardBg = contentBg leicht abgesetzt).
- Auto-Textfarbe soll min. 4.5:1 anstreben; falls nicht erreichbar, Warning anzeigen und bestmögliche Wahl treffen.

Bevor wir beginnen, gib Kommentare, wie gut du das findest und stelle Rückfragen. 